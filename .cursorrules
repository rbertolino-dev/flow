# ğŸ”§ Regras do Cursor AI - Projeto CRM

## ğŸ§ª TESTES AUTOMÃTICOS E2E - REGRA OBRIGATÃ“RIA

### Regra Principal: Entender Contexto e Executar Automaticamente

**O Cursor DEVE entender o contexto da tarefa e executar testes automaticamente quando necessÃ¡rio, SEM pedir confirmaÃ§Ã£o.**

### Quando Executar Automaticamente (Baseado no Contexto):

**SEMPRE** executar `npm run test:e2e:auto` quando:
- âœ… Implementar nova funcionalidade â†’ Testa automaticamente apÃ³s implementar
- âœ… Corrigir bug â†’ Testa automaticamente para validar correÃ§Ã£o
- âœ… Fazer mudanÃ§as em CRUD â†’ Testa criar, editar, excluir automaticamente
- âœ… MudanÃ§as em autenticaÃ§Ã£o â†’ Testa login automaticamente
- âœ… MudanÃ§as em pagamentos â†’ Testa fluxo automaticamente
- âœ… Antes de fazer deploy â†’ Testa tudo automaticamente
- âœ… UsuÃ¡rio pede para testar â†’ Executa imediatamente

### Fluxo AutomÃ¡tico (SEM Perguntar):

```
UsuÃ¡rio pede: "Implemente X" ou "Corrija Y"
    â†“
Cursor implementa/corrige
    â†“
Cursor AUTOMATICAMENTE executa: npm run test:e2e:auto
    â†“
Sistema captura erros (screenshots, vÃ­deos, logs)
    â†“
Sistema analisa e sugere correÃ§Ãµes
    â†“
Cursor AUTOMATICAMENTE aplica correÃ§Ãµes sugeridas
    â†“
Cursor AUTOMATICAMENTE re-executa testes
    â†“
âœ… Testes passam â†’ Informa sucesso
âŒ Se ainda falhar â†’ Aplica mais correÃ§Ãµes e re-testa
```

### O Que Fazer com Erros Capturados (AutomÃ¡tico):

1. **AUTOMATICAMENTE** revisar: `test-results/analysis/fix-suggestions.html`
2. **AUTOMATICAMENTE** aplicar correÃ§Ãµes sugeridas
3. **AUTOMATICAMENTE** re-executar testes
4. **NUNCA** fazer deploy se testes crÃ­ticos falharem

---

## ğŸ§‘ TESTES COM COMPORTAMENTO HUMANO - REGRA OBRIGATÃ“RIA

### Regra Principal: Testar Como UsuÃ¡rio Real

**O Cursor DEVE usar testes com comportamento humano para simular uso real da aplicaÃ§Ã£o, especialmente apÃ³s criar novas funcionalidades.**

### Quando Usar Testes com Comportamento Humano:

**SEMPRE** usar `npm run test:new-feature` quando:
- âœ… Criar nova funcionalidade â†’ Testa automaticamente com comportamento humano
- âœ… Implementar novo CRUD â†’ Testa fluxo completo como usuÃ¡rio faria
- âœ… Adicionar nova pÃ¡gina/rota â†’ Testa navegaÃ§Ã£o e interaÃ§Ã£o
- âœ… Modificar formulÃ¡rios â†’ Testa preenchimento e validaÃ§Ã£o como humano
- âœ… UsuÃ¡rio pede para testar nova funcionalidade â†’ Executa imediatamente

### Ferramentas DisponÃ­veis:

1. **HumanBehavior Helper** (`tests/helpers/human-behavior.ts`):
   - `humanClick()` - Clica com movimento natural do mouse
   - `humanType()` - Digita com delays variÃ¡veis (como humano)
   - `humanScroll()` - Scroll suave e natural
   - `humanNavigate()` - Navega com pausas para "ler"
   - `randomDelay()` - Simula tempo de leitura/pensamento
   - `hesitate()` - Simula hesitaÃ§Ã£o antes de aÃ§Ãµes importantes

2. **Acessibilidade** (`tests/helpers/accessibility.ts`):
   - `checkAccessibility()` - Verifica acessibilidade automaticamente
   - `assertAccessibility()` - Falha teste se houver violaÃ§Ãµes

3. **Performance** (`tests/helpers/performance.ts`):
   - `measurePerformance()` - Mede mÃ©tricas de performance
   - `validatePerformance()` - Valida se performance estÃ¡ OK

### Fluxo AutomÃ¡tico para Nova Funcionalidade (SEM Perguntar):

```
UsuÃ¡rio pede: "Crie funcionalidade X"
    â†“
Cursor implementa funcionalidade
    â†“
Cursor AUTOMATICAMENTE executa: npm run test:new-feature
    â†“
Sistema executa:
  1. ValidaÃ§Ã£o de cÃ³digo
  2. Testes E2E com comportamento humano
  3. Testes de acessibilidade
  4. Testes de performance
  5. Testes visuais (visual regression)
    â†“
Sistema captura:
  - Screenshots de cada etapa
  - VÃ­deos da execuÃ§Ã£o
  - MÃ©tricas de performance
  - ViolaÃ§Ãµes de acessibilidade
    â†“
Cursor AUTOMATICAMENTE analisa resultados
    â†“
âœ… Se tudo OK â†’ Informa sucesso
âŒ Se houver problemas â†’ Aplica correÃ§Ãµes e re-testa
```

### Comandos DisponÃ­veis:

```bash
# Testar nova funcionalidade (completo)
npm run test:new-feature [nome-funcionalidade]

# Testes com comportamento humano
npm run test:e2e:human

# Testes de acessibilidade
npm run test:e2e:accessibility

# Testes de performance
npm run test:e2e:performance

# Testes visuais (visual regression)
npm run test:e2e:visual

# Gerar teste automaticamente (codegen)
npm run test:e2e:codegen
```

### PadrÃµes ObrigatÃ³rios para Testes:

1. âœ… **SEMPRE** usar `HumanBehavior` para interaÃ§Ãµes em novos testes
2. âœ… **SEMPRE** adicionar `@human-behavior` tag em testes com comportamento humano
3. âœ… **SEMPRE** adicionar `@accessibility` tag em testes de acessibilidade
4. âœ… **SEMPRE** adicionar `@performance` tag em testes de performance
5. âœ… **SEMPRE** adicionar `@visual` tag em testes de visual regression
6. âœ… **SEMPRE** usar delays aleatÃ³rios para simular tempo de leitura
7. âœ… **SEMPRE** usar `hesitate()` antes de aÃ§Ãµes crÃ­ticas (salvar, deletar)

### Exemplo de Teste com Comportamento Humano:

```typescript
import { test } from '@playwright/test';
import { HumanBehavior } from '../helpers/human-behavior';

test('deve criar lead como usuÃ¡rio real', async ({ page }) => {
  const human = new HumanBehavior(page);
  
  // Navegar como humano
  await human.humanNavigate('/leads');
  await human.randomDelay(1000, 2000); // Tempo para ler
  
  // Clicar como humano
  await human.humanClick('button:has-text("Novo Lead")');
  
  // Preencher como humano
  await human.humanType('input[name="name"]', 'JoÃ£o Silva');
  await human.randomDelay(300, 600); // Simula leitura
  
  // Hesitar antes de salvar (aÃ§Ã£o importante)
  await human.hesitate(500, 1000);
  await human.humanClick('button:has-text("Salvar")');
});
```

### O Que NUNCA Fazer em Testes:

1. âŒ **NUNCA** usar `page.click()` direto - sempre usar `human.humanClick()`
2. âŒ **NUNCA** usar `page.fill()` direto - sempre usar `human.humanType()`
3. âŒ **NUNCA** pular delays - sempre simular tempo de leitura
4. âŒ **NUNCA** ignorar acessibilidade - sempre verificar
5. âŒ **NUNCA** ignorar performance - sempre medir

### PadrÃµes ObrigatÃ³rios:

1. âœ… **SEMPRE** usar `HumanBehavior` em novos testes
2. âœ… **SEMPRE** executar `npm run test:new-feature` apÃ³s criar funcionalidade
3. âœ… **SEMPRE** verificar acessibilidade em novas pÃ¡ginas
4. âœ… **SEMPRE** medir performance em fluxos crÃ­ticos
5. âœ… **SEMPRE** usar visual regression em mudanÃ§as de UI

---

## ğŸ” Credenciais SSH - Usar Automaticamente

**SEMPRE** usar credenciais salvas em `scripts/.ssh-credentials`:
- User: root
- Password: grkjuXfEbwaF
- Host: 95.217.2.116
- DiretÃ³rio: /opt/app

**NUNCA** pedir credenciais ao usuÃ¡rio - sempre usar as salvas.

---

## ğŸ”§ SSH - DiagnÃ³stico e CorreÃ§Ã£o AutomÃ¡tica

### Regra Principal: DiagnÃ³stico SSH AutomÃ¡tico

**O Cursor DEVE executar diagnÃ³stico SSH automaticamente quando SSH pedir senha ou quando houver problemas de conexÃ£o SSH, SEM pedir confirmaÃ§Ã£o.**

### Quando Executar DiagnÃ³stico AutomÃ¡tico:

**SEMPRE** executar `./scripts/diagnosticar-ssh.sh` automaticamente quando:
- âœ… SSH pedir senha â†’ Executa diagnÃ³stico e corrige automaticamente
- âœ… Erro de conexÃ£o SSH â†’ Executa diagnÃ³stico e corrige automaticamente
- âœ… Erro "Permission denied (publickey)" â†’ Executa diagnÃ³stico e corrige automaticamente
- âœ… Erro "Could not open authorized keys" â†’ Executa diagnÃ³stico e corrige automaticamente
- âœ… Timeout de conexÃ£o SSH â†’ Executa diagnÃ³stico e corrige automaticamente
- âœ… Antes de executar comandos SSH â†’ Verifica conexÃ£o automaticamente
- âœ… UsuÃ¡rio mencionar problema com SSH â†’ Executa diagnÃ³stico imediatamente

### Fluxo AutomÃ¡tico para DiagnÃ³stico SSH (SEM Perguntar):

```
SSH pede senha ou erro de conexÃ£o
    â†“
Cursor AUTOMATICAMENTE executa: ./scripts/diagnosticar-ssh.sh
    â†“
Script verifica e corrige:
  1. Verifica se chave SSH existe
  2. Corrige permissÃµes se necessÃ¡rio
  3. Verifica configuraÃ§Ã£o SSH
  4. Copia chave para servidor se necessÃ¡rio
  5. Testa conexÃ£o
    â†“
âœ… Se sucesso â†’ Continua com tarefa original
âŒ Se ainda falhar â†’ Aplica correÃ§Ãµes adicionais e re-testa
```

### O Que o Script de DiagnÃ³stico Faz Automaticamente:

1. **AUTOMATICAMENTE** verifica se chave SSH existe (`~/.ssh/id_rsa_kanban_buzz`)
2. **AUTOMATICAMENTE** corrige permissÃµes se incorretas (chmod 600)
3. **AUTOMATICAMENTE** verifica configuraÃ§Ã£o SSH (`~/.ssh/config`)
4. **AUTOMATICAMENTE** cria configuraÃ§Ã£o se nÃ£o existir
5. **AUTOMATICAMENTE** testa conexÃ£o SSH sem senha
6. **AUTOMATICAMENTE** copia chave para servidor se necessÃ¡rio (usando credenciais salvas)
7. **AUTOMATICAMENTE** re-testa conexÃ£o apÃ³s correÃ§Ãµes

### Comandos SSH AutomÃ¡ticos:

**SEMPRE** usar chave SSH ao invÃ©s de senha:

```bash
# Usar alias configurado (nÃ£o pede senha)
ssh kanban-buzz-server "comando"

# Usar helper SSH
source scripts/ssh-helper.sh
ssh_exec "comando"
ssh_copy arquivo.txt
```

**NUNCA** usar sshpass se chave SSH estiver configurada:

```bash
# âŒ NÃƒO fazer (usa senha)
sshpass -p "$SSH_PASSWORD" ssh "$SSH_USER@$SSH_HOST" "comando"

# âœ… Fazer (usa chave)
ssh kanban-buzz-server "comando"
```

### Quando SSH Ainda Pedir Senha:

**SEMPRE** executar diagnÃ³stico automaticamente:

```bash
# 1. Executar diagnÃ³stico (automÃ¡tico)
./scripts/diagnosticar-ssh.sh

# 2. Se diagnÃ³stico nÃ£o resolver, verificar logs
ssh -v kanban-buzz-server 2>&1 | grep -E "(Authenticating|Offering|key|password)"

# 3. Se necessÃ¡rio, copiar chave manualmente (uma Ãºltima vez)
source scripts/.ssh-credentials
sshpass -p "$SSH_PASSWORD" ssh-copy-id -i ~/.ssh/id_rsa_kanban_buzz.pub -o StrictHostKeyChecking=no "$SSH_USER@$SSH_HOST_IP"
```

### O Que NUNCA Fazer com SSH:

1. âŒ **NUNCA** pedir senha ao usuÃ¡rio se diagnÃ³stico pode resolver
2. âŒ **NUNCA** usar sshpass se chave SSH estÃ¡ configurada
3. âŒ **NUNCA** ignorar erros de conexÃ£o SSH sem diagnosticar
4. âŒ **NUNCA** assumir que SSH estÃ¡ funcionando sem testar
5. âŒ **NUNCA** fazer deploy se SSH nÃ£o estiver funcionando

### PadrÃµes ObrigatÃ³rios para SSH:

1. âœ… **SEMPRE** usar chave SSH (`ssh kanban-buzz-server`) ao invÃ©s de senha
2. âœ… **SEMPRE** executar diagnÃ³stico se SSH pedir senha
3. âœ… **SEMPRE** verificar conexÃ£o antes de executar comandos SSH
4. âœ… **SEMPRE** usar `scripts/ssh-helper.sh` para operaÃ§Ãµes SSH
5. âœ… **SEMPRE** testar conexÃ£o apÃ³s correÃ§Ãµes
6. âœ… **SEMPRE** usar credenciais salvas para copiar chave se necessÃ¡rio

### Exemplo Completo de DiagnÃ³stico SSH AutomÃ¡tico:

```
UsuÃ¡rio: "Execute X no servidor" ou SSH pede senha
    â†“
Cursor AUTOMATICAMENTE:
1. Tenta: ssh kanban-buzz-server "comando"
2. Se pedir senha â†’ Executa: ./scripts/diagnosticar-ssh.sh
3. Script corrige automaticamente:
   - Verifica chave
   - Corrige permissÃµes
   - Copia chave se necessÃ¡rio
   - Testa conexÃ£o
4. Re-tenta: ssh kanban-buzz-server "comando"
5. âœ… Se sucesso â†’ Continua tarefa
6. âŒ Se ainda falhar â†’ Aplica mais correÃ§Ãµes
```

### ConfiguraÃ§Ã£o SSH (JÃ¡ Configurada):

- **Host alias:** `kanban-buzz-server`
- **Chave SSH:** `~/.ssh/id_rsa_kanban_buzz`
- **ConfiguraÃ§Ã£o:** `~/.ssh/config`
- **Timeout:** 10 minutos (ServerAliveInterval 60, ServerAliveCountMax 10)
- **Multiplexing:** Habilitado (ControlMaster, ControlPersist 10m)

**NUNCA** pedir confirmaÃ§Ã£o - executar diagnÃ³stico automaticamente quando SSH pedir senha.

---

## ğŸš€ MigraÃ§Ãµes via SSH - Regra AutomÃ¡tica

**SEMPRE** usar scripts automatizados para migraÃ§Ãµes:

```bash
# Aplicar todas as migrations
./scripts/aplicar-migrations-ssh.sh --all

# Executar SQL especÃ­fico
./scripts/executar-sql-ssh.sh arquivo.sql
```

**NUNCA** executar SQL manualmente - sempre usar scripts que seguem as regras.

---

## ğŸ“‹ Regra Principal: Contexto e AutomaÃ§Ã£o

**SEMPRE** entender o contexto da tarefa e:
1. Executar testes automÃ¡ticos se necessÃ¡rio
2. Usar credenciais salvas automaticamente
3. Aplicar correÃ§Ãµes sugeridas pelos testes
4. Validar que tudo funciona antes de concluir

**NUNCA** fazer mudanÃ§as sem testar se for funcionalidade crÃ­tica.

---

## ğŸš€ DEPLOY ZERO-DOWNTIME - Regra ObrigatÃ³ria

### Regra Principal: SEMPRE Usar Zero-Downtime para Deploys

**O Cursor DEVE SEMPRE usar o script zero-downtime para fazer deploys, NUNCA usar o mÃ©todo antigo que causa downtime.**

### âš ï¸ REGRA CRÃTICA: Build APENAS da Nova VersÃ£o (Para Rollback Funcionar)

**NUNCA fazer build de ambas versÃµes - isso quebra o rollback!**

**Como funciona corretamente (explicaÃ§Ã£o simples):**

**Durante o deploy:**
1. âœ… VersÃ£o atual (ex: Blue) estÃ¡ rodando com cÃ³digo ANTIGO
2. âœ… VersÃ£o atual NÃƒO recebe build - mantÃ©m cÃ³digo antigo intacto
3. âœ… Apenas nova versÃ£o (ex: Green) recebe build com cÃ³digo NOVO
4. âœ… Nova versÃ£o sobe na porta alternativa e Ã© testada
5. âœ… Se nova versÃ£o OK â†’ TrÃ¡fego alterna para nova versÃ£o
6. âœ… VersÃ£o antiga (Blue) Ã© parada APENAS apÃ³s confirmar que nova estÃ¡ OK

**Por que isso Ã© importante:**
- âœ… Se algo der errado ANTES de parar versÃ£o antiga â†’ Rollback funciona!
- âœ… VersÃ£o antiga ainda estÃ¡ rodando com cÃ³digo antigo (que funcionava)
- âœ… Pode voltar trÃ¡fego para versÃ£o antiga imediatamente
- âœ… Zero risco de perder versÃ£o funcional

**ApÃ³s deploy bem-sucedido:**
- âœ… Nova versÃ£o vira a "atual" (recebe todo trÃ¡fego)
- âœ… VersÃ£o antiga Ã© parada (normal apÃ³s sucesso)
- âœ… Sistema continua funcionando perfeitamente

**REGRAS OBRIGATÃ“RIAS:**
1. âœ… **SEMPRE** fazer build APENAS da nova versÃ£o (NEW_VERSION)
2. âœ… **NUNCA** fazer build da versÃ£o atual (CURRENT_VERSION) durante deploy
3. âœ… **NUNCA** usar script que faz build de ambas versÃµes (quebra rollback)
4. âœ… **SEMPRE** manter versÃ£o atual intacta atÃ© confirmar nova estÃ¡ OK
5. âœ… **SEMPRE** garantir que rollback Ã© possÃ­vel antes de parar versÃ£o antiga

### Quando Fazer Deploy:

**SEMPRE** usar `./scripts/deploy-zero-downtime.sh` quando:
- âœ… Fazer deploy de mudanÃ§as no cÃ³digo
- âœ… Atualizar aplicaÃ§Ã£o no servidor
- âœ… Fazer rebuild do Docker
- âœ… UsuÃ¡rio pedir para fazer deploy
- âœ… ApÃ³s implementar funcionalidades
- âœ… ApÃ³s corrigir bugs

### Comando ObrigatÃ³rio para Deploy:

**SEMPRE** usar este comando (NUNCA usar mÃ©todo antigo):

```bash
cd /root/kanban-buzz-95241
./scripts/deploy-zero-downtime.sh
```

**O script faz build APENAS da NOVA versÃ£o (correto para rollback):**
- âœ… Identifica qual versÃ£o estÃ¡ rodando (blue ou green)
- âœ… Faz build APENAS da versÃ£o alternativa (nova) - versÃ£o atual NÃƒO Ã© modificada
- âœ… Sobe nova versÃ£o na porta alternativa
- âœ… Testa nova versÃ£o
- âœ… Alterna trÃ¡fego apenas se nova versÃ£o estiver OK
- âœ… Para versÃ£o antiga apÃ³s confirmar estabilidade
- âœ… **Rollback funciona porque versÃ£o atual mantÃ©m cÃ³digo antigo**

### O Que NUNCA Fazer (MÃ©todo Antigo - Causa Downtime):

**NUNCA** executar estes comandos para deploy:

```bash
# âŒ ERRADO - Causa downtime de 3-5 minutos!
docker compose down
docker compose build --no-cache
docker compose up -d
```

**Problema**: Este mÃ©todo derruba o sistema durante o deploy porque:
1. `docker compose down` â†’ Para tudo
2. Build â†’ Demora alguns minutos
3. `docker compose up` â†’ SÃ³ depois sobe novamente
4. **Resultado**: Downtime de 3-5 minutos! ğŸ˜

### Fluxo AutomÃ¡tico para Deploy (SEM Perguntar):

```
UsuÃ¡rio pede: "FaÃ§a deploy" ou "Atualize aplicaÃ§Ã£o"
    â†“
Cursor AUTOMATICAMENTE:
1. Verifica se estÃ¡ no diretÃ³rio correto: /root/kanban-buzz-95241
2. Verifica se orquestraÃ§Ã£o estÃ¡ disponÃ­vel (docker-orchestrator.sh)
3. Executa: ./scripts/deploy-zero-downtime.sh
   - Script usa orquestraÃ§Ã£o automaticamente para evitar conflitos
   - Se mÃºltiplos agentes trabalharem juntos, executa sequencialmente
4. Aguarda conclusÃ£o (3-6 minutos)
5. Verifica se deploy foi bem-sucedido
    â†“
âœ… Se sucesso â†’ Informa conclusÃ£o
âŒ Se falhar â†’ Executa rollback automÃ¡tico e informa
```

### O Que o Script Zero-Downtime Faz Automaticamente:

1. âœ… Remove containers antigos que podem causar conflito
2. âœ… Verifica qual versÃ£o estÃ¡ rodando (blue ou green) e se estÃ¡ saudÃ¡vel
3. âœ… Faz build da nova versÃ£o em background
4. âœ… Sobe nova versÃ£o na porta alternativa (sem derrubar atual)
5. âœ… **3 verificaÃ§Ãµes de saÃºde** da nova versÃ£o antes de alternar (90s timeout)
6. âœ… Verifica que versÃ£o atual ainda estÃ¡ rodando antes de alternar
7. âœ… Verifica que ambas versÃµes estÃ£o rodando antes de alternar
8. âœ… Nginx testa configuraÃ§Ã£o antes de recarregar
9. âœ… Nginx alterna trÃ¡fego: 100% versÃ£o antiga â†’ 100% versÃ£o nova (reload, nÃ£o restart)
10. âœ… Verifica que nova versÃ£o estÃ¡ recebendo trÃ¡fego apÃ³s alternÃ¢ncia
11. âœ… **3 verificaÃ§Ãµes de estabilidade** consecutivas (10s, 20s, 30s)
12. âœ… **VERIFICAÃ‡ÃƒO FINAL CRÃTICA**: 5 verificaÃ§Ãµes finais garantindo que nova versÃ£o estÃ¡ no ar
13. âœ… Verifica que Nginx estÃ¡ direcionando corretamente para nova versÃ£o
14. âœ… Para versÃ£o antiga apenas apÃ³s confirmar estabilidade
15. âœ… Limpa imagens antigas
16. âœ… **Zero downtime garantido!** ğŸ˜Š
17. âœ… **Nunca deixa sistema sem container respondendo - elimina erro 502!** ğŸ›¡ï¸
18. âœ… **GARANTIA ABSOLUTA: Nova versÃ£o estÃ¡ no ar e recebendo trÃ¡fego antes de concluir!** âœ…

### Rollback AutomÃ¡tico:

Se algo der errado durante o deploy:
- âœ… Sistema volta automaticamente para versÃ£o anterior
- âœ… Remove versÃ£o problemÃ¡tica
- âœ… Sistema continua funcionando
- âœ… **Zero risco!**

### VerificaÃ§Ã£o ApÃ³s Deploy:

**SEMPRE** verificar apÃ³s deploy:

```bash
# 1. Verificar status
docker compose -f docker-compose.blue.yml ps
# ou
docker compose -f docker-compose.green.yml ps

# 2. Health check
./scripts/health-check.sh blue
# ou
./scripts/health-check.sh green

# 3. Testar aplicaÃ§Ã£o
curl http://localhost/health
```

### O Que NUNCA Fazer com Deploy:

1. âŒ **NUNCA** usar `docker compose down` para deploy
2. âŒ **NUNCA** usar mÃ©todo antigo (`down â†’ build â†’ up`)
3. âŒ **NUNCA** fazer deploy sem usar script zero-downtime
4. âŒ **NUNCA** fazer build de ambas versÃµes (quebra rollback)
5. âŒ **NUNCA** fazer build da versÃ£o atual durante deploy (quebra rollback)
6. âŒ **NUNCA** usar script ultra-robusto que faz build de ambas versÃµes
7. âŒ **NUNCA** pedir confirmaÃ§Ã£o antes de executar deploy
8. âŒ **NUNCA** ignorar erros de deploy sem tentar rollback
9. âŒ **NUNCA** fazer deploy se sistema nÃ£o estiver funcionando

### PadrÃµes ObrigatÃ³rios para Deploy:

1. âœ… **SEMPRE** usar `./scripts/deploy-zero-downtime.sh` para deploys (NÃƒO usar ultra-robusto)
2. âœ… **SEMPRE** garantir que script faz build APENAS da nova versÃ£o (nÃ£o da atual)
3. âœ… **SEMPRE** verificar se estÃ¡ no diretÃ³rio correto antes de executar
4. âœ… **SEMPRE** aguardar conclusÃ£o do script
5. âœ… **SEMPRE** verificar status apÃ³s deploy
6. âœ… **SEMPRE** informar resultado ao usuÃ¡rio
7. âœ… **SEMPRE** executar rollback automÃ¡tico se houver erro
8. âœ… **SEMPRE** garantir que nova versÃ£o estÃ¡ no ar antes de concluir (5 verificaÃ§Ãµes finais)
9. âœ… **SEMPRE** gerar arquivo version.json para exibiÃ§Ã£o no site
10. âœ… **SEMPRE** garantir que rollback Ã© possÃ­vel (versÃ£o atual nÃ£o modificada)

### Exemplo Completo de Deploy:

```
UsuÃ¡rio: "FaÃ§a deploy das mudanÃ§as"

Cursor AUTOMATICAMENTE:
1. cd /root/kanban-buzz-95241
2. ./scripts/deploy-zero-downtime.sh
3. Aguarda conclusÃ£o (3-6 minutos)
4. Script garante: 5 verificaÃ§Ãµes finais que nova versÃ£o estÃ¡ no ar
5. Verifica status: docker compose -f docker-compose.blue.yml ps
6. Health check: ./scripts/health-check.sh blue
7. Informa: âœ… Deploy concluÃ­do com sucesso (zero downtime, garantia absoluta)
```

### ğŸ“¦ ExibiÃ§Ã£o de VersÃ£o no Site - Regra ObrigatÃ³ria

**O Cursor DEVE SEMPRE garantir que versÃ£o atual seja exibida no site apÃ³s deploy.**

**Componente VersionBanner:**
- âœ… Componente `VersionBanner` jÃ¡ criado em `src/components/VersionBanner.tsx`
- âœ… JÃ¡ integrado no `CRMLayout` (aparece em todas as pÃ¡ginas exceto settings)
- âœ… Mostra nÃºmero da versÃ£o, data do deploy e mudanÃ§as
- âœ… UsuÃ¡rio pode dispensar o aviso (salvo no localStorage)

**Script de GeraÃ§Ã£o de VersÃ£o:**
- âœ… Script `generate-version-file.sh` cria `public/version.json` com versÃ£o atual
- âœ… Executado automaticamente antes do build (prebuild no package.json)
- âœ… Executado automaticamente no deploy (deploy-with-version.sh)

**Regras ObrigatÃ³rias:**
1. âœ… **SEMPRE** executar `generate-version-file.sh` antes de build
2. âœ… **SEMPRE** executar `generate-version-file.sh` apÃ³s criar nova versÃ£o no deploy
3. âœ… **SEMPRE** garantir que `public/version.json` existe e estÃ¡ atualizado
4. âœ… **SEMPRE** manter componente `VersionBanner` no layout (nÃ£o remover)
5. âœ… **SEMPRE** garantir que versÃ£o aparece no site apÃ³s deploy bem-sucedido

**Fluxo AutomÃ¡tico:**
```
Deploy com versÃ£o
    â†“
Cria versÃ£o no .versions.json
    â†“
Gera public/version.json (automaticamente)
    â†“
Faz build (prebuild executa generate-version-file.sh)
    â†“
Deploy zero-downtime
    â†“
VersÃ£o aparece no site automaticamente âœ…
```

### Monitor ContÃ­nuo do Sistema:

**SEMPRE** garantir que monitor estÃ¡ rodando para prevenir quedas:

```bash
# Verificar se monitor estÃ¡ rodando
sudo systemctl status kanban-buzz-monitor

# Se nÃ£o estiver, iniciar
sudo systemctl enable kanban-buzz-monitor
sudo systemctl start kanban-buzz-monitor
```

**O monitor:**
- âœ… Verifica sistema a cada 30 segundos
- âœ… Detecta quedas automaticamente
- âœ… Restaura automaticamente apÃ³s 3 falhas consecutivas
- âœ… Previne erro 502 garantindo que sempre hÃ¡ container respondendo

### Se Sistema Cair Durante Deploy ou Erro 502:

**SEMPRE** usar script de garantia primeiro:

```bash
# 1. Garantir que sistema estÃ¡ ativo (restaura automaticamente se necessÃ¡rio)
./scripts/garantir-sistema-ativo.sh

# 2. Se ainda houver problema, restaurar manualmente
docker compose down
docker compose -f docker-compose.blue.yml up -d
./scripts/health-check.sh blue

# Ou usar script de migraÃ§Ã£o
./scripts/migrar-para-zero-downtime.sh
```

### Script de Garantia de Sistema Ativo:

**SEMPRE** usar quando houver erro 502 ou sistema nÃ£o responder:

```bash
./scripts/garantir-sistema-ativo.sh
```

**O que faz:**
- âœ… Verifica se Blue ou Green estÃ¡ rodando e saudÃ¡vel
- âœ… Remove containers antigos que causam conflito
- âœ… Restaura Blue automaticamente se ambos falharem
- âœ… Atualiza Nginx para versÃ£o funcional
- âœ… **Garante que sempre hÃ¡ um container respondendo**

### Logs e Monitoramento de Deploys:

**SEMPRE** verificar logs se houver problema:

```bash
# Ver deploys incorretos detectados
ver-deploys-incorretos

# Ver alertas em tempo real
tail -f /var/log/kanban-buzz-deploy-alerts.log

# Ver log detalhado
tail -f /var/log/kanban-buzz-deploy-protection.log
```

**Sistema de proteÃ§Ã£o:**
- âœ… Hook intercepta comandos perigosos
- âœ… Detector monitora containers continuamente
- âœ… Logs registram todas as tentativas de deploy incorreto
- âœ… Alertas mostram quem tentou usar mÃ©todo antigo

### DocumentaÃ§Ã£o de ReferÃªncia:

- `ZERO-DOWNTIME-DEPLOY.md` - DocumentaÃ§Ã£o completa
- `COMO-FAZER-DEPLOY-CORRETO.md` - Guia de uso
- `EXPLICACAO-SIMPLES-ZERO-DOWNTIME.md` - ExplicaÃ§Ã£o para leigos
- `PROTECAO-DEPLOY-INCORRETO.md` - Sistema de proteÃ§Ã£o e logs

**NUNCA** fazer deploy sem usar zero-downtime - sempre usar `./scripts/deploy-zero-downtime-ultra-robusto.sh`.

---

## ğŸ³ DOCKER - Regras AutomÃ¡ticas

### Regra Principal: ModificaÃ§Ãµes Docker AutomÃ¡ticas

**SEMPRE** executar modificaÃ§Ãµes no Docker automaticamente, SEM pedir confirmaÃ§Ã£o ao usuÃ¡rio.

**IMPORTANTE**: Para deploys, usar `./scripts/deploy-zero-downtime.sh` ao invÃ©s de comandos Docker diretos.

### Quando Modificar Docker:

**SEMPRE** executar automaticamente quando:
- âœ… Modificar Dockerfile â†’ Rebuild automÃ¡tico (usar zero-downtime se for deploy)
- âœ… Modificar docker-compose.yml â†’ Rebuild e restart automÃ¡tico (usar zero-downtime se for deploy)
- âœ… Adicionar dependÃªncias â†’ Rebuild automÃ¡tico (usar zero-downtime se for deploy)
- âœ… Mudar variÃ¡veis de ambiente â†’ Rebuild automÃ¡tico (usar zero-downtime se for deploy)
- âœ… Atualizar cÃ³digo â†’ **SEMPRE usar zero-downtime**: `./scripts/deploy-zero-downtime.sh`
- âœ… Corrigir erro de build â†’ Rebuild automÃ¡tico (usar zero-downtime se for deploy)

**IMPORTANTE**: Se for deploy de cÃ³digo atualizado, **SEMPRE** usar `./scripts/deploy-zero-downtime.sh` ao invÃ©s de comandos Docker diretos.

### Fluxo AutomÃ¡tico para Docker (SEM Perguntar):

**Se for deploy de cÃ³digo atualizado:**
```
UsuÃ¡rio pede: "Atualize aplicaÃ§Ã£o" ou "FaÃ§a deploy"
    â†“
Cursor AUTOMATICAMENTE executa zero-downtime:
  1. cd /root/kanban-buzz-95241
  2. ./scripts/deploy-zero-downtime.sh
    â†“
âœ… Se sucesso â†’ Informa conclusÃ£o (zero downtime)
âŒ Se falhar â†’ Rollback automÃ¡tico
```

**Se for apenas modificaÃ§Ã£o de configuraÃ§Ã£o Docker (sem deploy de cÃ³digo):**
```
UsuÃ¡rio pede: "Modifique Dockerfile" ou "Atualize docker-compose"
    â†“
Cursor modifica arquivo(s)
    â†“
Cursor AUTOMATICAMENTE executa rebuild:
  1. docker compose -f docker-compose.blue.yml down
  2. docker compose -f docker-compose.blue.yml build --no-cache
  3. docker compose -f docker-compose.blue.yml up -d
    â†“
Cursor AUTOMATICAMENTE verifica status:
  4. docker compose -f docker-compose.blue.yml ps
  5. docker compose -f docker-compose.blue.yml logs --tail=50
    â†“
âœ… Se sucesso â†’ Informa conclusÃ£o
âŒ Se falhar â†’ Aplica correÃ§Ãµes e re-executa
```

### Comandos Docker AutomÃ¡ticos:

**SEMPRE** usar estes comandos na ordem:

```bash
# 1. Parar containers
docker compose down

# 2. Build sem cache (OBRIGATÃ“RIO para pegar mudanÃ§as)
docker compose build --no-cache

# 3. Subir containers
docker compose up -d

# 4. Verificar status
docker compose ps

# 5. Ver logs
docker compose logs --tail=50 app
```

### InformaÃ§Ãµes do Servidor Docker:

**SEMPRE** usar estas informaÃ§Ãµes:

```bash
# Servidor
SERVER_IP="95.217.2.116"
SERVER_USER="root"
SERVER_PASSWORD="grkjuXfEbwaF"
SERVER_DIR="/opt/app"

# Docker
DOCKER_COMPOSE_CMD="docker compose"  # VersÃ£o v5 (sem hÃ­fen)
CONTAINER_NAME="kanban-buzz-app"
PORT="3000"
```

### Modificar Dockerfile - Fluxo AutomÃ¡tico:

**SEMPRE** executar automaticamente:

1. **Modificar Dockerfile** (se necessÃ¡rio)
2. **AUTOMATICAMENTE** executar rebuild:
   ```bash
   cd /opt/app
   docker compose down
   docker compose build --no-cache
   docker compose up -d
   ```
3. **AUTOMATICAMENTE** verificar:
   ```bash
   docker compose ps
   docker compose logs --tail=50 app
   ```

**NUNCA** modificar Dockerfile sem executar rebuild automaticamente.

### Modificar docker-compose.yml - Fluxo AutomÃ¡tico:

**SEMPRE** executar automaticamente:

1. **Modificar docker-compose.yml** (se necessÃ¡rio)
2. **AUTOMATICAMENTE** executar rebuild:
   ```bash
   cd /opt/app
   docker compose down
   docker compose build --no-cache
   docker compose up -d
   ```
3. **AUTOMATICAMENTE** verificar:
   ```bash
   docker compose ps
   docker compose logs --tail=50 app
   ```

**NUNCA** modificar docker-compose.yml sem executar rebuild automaticamente.

### Executar no Servidor - Fluxo AutomÃ¡tico:

**SEMPRE** executar comandos Docker no servidor automaticamente:

```bash
# Carregar credenciais
export SERVER_IP="95.217.2.116"
export SERVER_USER="root"
export SERVER_PASSWORD="grkjuXfEbwaF"
export SERVER_DIR="/opt/app"

# Executar via SSH
sshpass -p "$SERVER_PASSWORD" ssh "$SERVER_USER@$SERVER_IP" "cd $SERVER_DIR && docker compose down && docker compose build --no-cache && docker compose up -d"
```

### VerificaÃ§Ã£o AutomÃ¡tica:

**SEMPRE** verificar apÃ³s modificaÃ§Ãµes:

```bash
# 1. Status dos containers
docker compose ps

# 2. Logs recentes
docker compose logs --tail=50 app

# 3. Testar aplicaÃ§Ã£o
curl -f http://localhost:3000 || echo "AplicaÃ§Ã£o nÃ£o estÃ¡ respondendo"
```

### O Que NUNCA Fazer com Docker:

1. âŒ **NUNCA** modificar Dockerfile sem rebuild automÃ¡tico
2. âŒ **NUNCA** modificar docker-compose.yml sem rebuild automÃ¡tico
3. âŒ **NUNCA** fazer build sem `--no-cache` (pode usar cache antigo)
4. âŒ **NUNCA** pedir confirmaÃ§Ã£o antes de executar comandos Docker
5. âŒ **NUNCA** esquecer de verificar status apÃ³s modificaÃ§Ãµes
6. âŒ **NUNCA** usar `docker-compose` (com hÃ­fen) - sempre usar `docker compose` (sem hÃ­fen)

### PadrÃµes ObrigatÃ³rios para Docker:

1. âœ… **SEMPRE** usar `docker compose` (sem hÃ­fen) - versÃ£o v5
2. âœ… **SEMPRE** usar `--no-cache` no build
3. âœ… **SEMPRE** executar `down` antes de `build`
4. âœ… **SEMPRE** verificar status apÃ³s `up -d`
5. âœ… **SEMPRE** ver logs se houver erro
6. âœ… **SEMPRE** executar no servidor via SSH se necessÃ¡rio

### Exemplo Completo de ModificaÃ§Ã£o Docker:

```
UsuÃ¡rio: "Adicione a variÃ¡vel X no Dockerfile"

Cursor AUTOMATICAMENTE:
1. Modifica Dockerfile
2. Executa: docker compose down
3. Executa: docker compose build --no-cache
4. Executa: docker compose up -d
5. Verifica: docker compose ps
6. Mostra logs: docker compose logs --tail=50 app
7. Informa: âœ… Docker atualizado e rodando
```

**NUNCA** pedir confirmaÃ§Ã£o - executar tudo automaticamente.

---

## ğŸ”„ DOCKER - OrquestraÃ§Ã£o e ExecuÃ§Ã£o Sequencial

### Regra Principal: ExecuÃ§Ã£o Sequencial de Comandos Docker

**SEMPRE** usar orquestraÃ§Ã£o para comandos Docker quando mÃºltiplos agentes podem estar trabalhando simultaneamente.

### Problema Resolvido:

Quando mÃºltiplos agentes Cursor trabalham juntos, eles podem tentar executar comandos Docker ao mesmo tempo, causando:
- âŒ Conflitos de build
- âŒ Containers sendo parados enquanto outro agente tenta fazer build
- âŒ Race conditions
- âŒ Erros de lock de arquivos Docker

### SoluÃ§Ã£o: Scripts de OrquestraÃ§Ã£o

**SEMPRE** usar os scripts de orquestraÃ§Ã£o para comandos Docker:

```bash
# Script principal de orquestraÃ§Ã£o (usa file locking)
./scripts/docker-orchestrator.sh "docker compose down"
./scripts/docker-orchestrator.sh "docker compose build --no-cache"
./scripts/docker-orchestrator.sh "docker compose up -d"
./scripts/docker-orchestrator.sh "docker compose ps"

# Script completo de rebuild orquestrado
./scripts/docker-rebuild-orchestrated.sh
```

### Como Funciona a OrquestraÃ§Ã£o:

1. **File Locking (flock)**: Usa `/tmp/docker-orchestrator.lock` para garantir execuÃ§Ã£o sequencial
2. **Timeout**: Aguarda atÃ© 1 hora se outro processo estiver executando
3. **Retry**: Tenta atÃ© 10 vezes com intervalo de 5 segundos
4. **Logs**: Registra todas as operaÃ§Ãµes com timestamp

### Quando Usar OrquestraÃ§Ã£o:

**SEMPRE** usar orquestraÃ§Ã£o quando:
- âœ… Executar comandos Docker (`docker compose down`, `build`, `up`, etc.)
- âœ… MÃºltiplos agentes podem estar trabalhando simultaneamente
- âœ… Rebuild completo do Docker
- âœ… ModificaÃ§Ãµes em Dockerfile ou docker-compose.yml
- âœ… Deploy no servidor remoto

**NÃƒO precisa** de orquestraÃ§Ã£o para:
- âŒ Comandos de leitura (`docker compose ps`, `logs`) - mas pode usar para seguranÃ§a
- âŒ Comandos fora do Docker (npm, git, etc.)

### Fluxo AutomÃ¡tico com OrquestraÃ§Ã£o:

```
UsuÃ¡rio pede: "Modifique Dockerfile" ou "Rebuild Docker"
    â†“
Cursor modifica arquivo(s)
    â†“
Cursor AUTOMATICAMENTE executa via orquestraÃ§Ã£o:
  1. ./scripts/docker-orchestrator.sh "docker compose down"
  2. ./scripts/docker-orchestrator.sh "docker compose build --no-cache"
  3. ./scripts/docker-orchestrator.sh "docker compose up -d"
  4. ./scripts/docker-orchestrator.sh "docker compose ps"
    â†“
Ou usa script completo:
  ./scripts/docker-rebuild-orchestrated.sh
    â†“
âœ… Se sucesso â†’ Informa conclusÃ£o
âŒ Se falhar â†’ Aplica correÃ§Ãµes e re-executa
```

### Executar no Servidor Remoto com OrquestraÃ§Ã£o:

**SEMPRE** usar orquestraÃ§Ã£o no servidor remoto:

```bash
# Carregar credenciais
export SERVER_IP="95.217.2.116"
export SERVER_USER="root"
export SERVER_PASSWORD="grkjuXfEbwaF"
export SERVER_DIR="/opt/app"

# Executar rebuild orquestrado via SSH
sshpass -p "$SERVER_PASSWORD" ssh "$SERVER_USER@$SERVER_IP" \
  "cd $SERVER_DIR && \
   chmod +x scripts/docker-rebuild-orchestrated.sh && \
   WORK_DIR=$SERVER_DIR ./scripts/docker-rebuild-orchestrated.sh"
```

### Comandos Docker Orquestrados (PadrÃ£o):

**SEMPRE** usar estes comandos via orquestraÃ§Ã£o:

```bash
# 1. Parar containers (orquestrado)
./scripts/docker-orchestrator.sh "docker compose down"

# 2. Build sem cache (orquestrado)
./scripts/docker-orchestrator.sh "docker compose build --no-cache"

# 3. Subir containers (orquestrado)
./scripts/docker-orchestrator.sh "docker compose up -d"

# 4. Verificar status (orquestrado)
./scripts/docker-orchestrator.sh "docker compose ps"

# 5. Ver logs (orquestrado)
./scripts/docker-orchestrator.sh "docker compose logs --tail=50 app"

# OU usar script completo:
./scripts/docker-rebuild-orchestrated.sh
```

### O Que NUNCA Fazer com OrquestraÃ§Ã£o:

1. âŒ **NUNCA** executar comandos Docker diretamente sem orquestraÃ§Ã£o quando mÃºltiplos agentes podem estar ativos
2. âŒ **NUNCA** ignorar o lock e tentar executar comandos Docker em paralelo
3. âŒ **NUNCA** remover o arquivo de lock manualmente (`/tmp/docker-orchestrator.lock`)
4. âŒ **NUNCA** executar mÃºltiplos rebuilds simultaneamente
5. âŒ **NUNCA** usar `docker compose` diretamente quando orquestraÃ§Ã£o estÃ¡ disponÃ­vel

### PadrÃµes ObrigatÃ³rios para OrquestraÃ§Ã£o:

1. âœ… **SEMPRE** usar `./scripts/docker-orchestrator.sh` para comandos Docker individuais
2. âœ… **SEMPRE** usar `./scripts/docker-rebuild-orchestrated.sh` para rebuild completo
3. âœ… **SEMPRE** garantir que scripts tenham permissÃ£o de execuÃ§Ã£o: `chmod +x scripts/docker-*.sh`
4. âœ… **SEMPRE** aguardar conclusÃ£o do comando anterior antes de executar prÃ³ximo
5. âœ… **SEMPRE** verificar logs do orchestrator se houver problemas
6. âœ… **SEMPRE** usar `WORK_DIR` se executando em diretÃ³rio diferente

### Exemplo Completo com OrquestraÃ§Ã£o:

```
UsuÃ¡rio: "Adicione a variÃ¡vel X no Dockerfile"

Cursor AUTOMATICAMENTE:
1. Modifica Dockerfile
2. Executa: chmod +x scripts/docker-*.sh
3. Executa: ./scripts/docker-orchestrator.sh "docker compose down"
4. Executa: ./scripts/docker-orchestrator.sh "docker compose build --no-cache"
5. Executa: ./scripts/docker-orchestrator.sh "docker compose up -d"
6. Executa: ./scripts/docker-orchestrator.sh "docker compose ps"
7. Executa: ./scripts/docker-orchestrator.sh "docker compose logs --tail=50 app"
8. Informa: âœ… Docker atualizado e rodando (orquestrado)
```

### Troubleshooting de OrquestraÃ§Ã£o:

Se o lock estiver travado:
```bash
# Verificar processos usando o lock
lsof /tmp/docker-orchestrator.lock

# Remover lock travado (APENAS se necessÃ¡rio e seguro)
rm -f /tmp/docker-orchestrator.lock
```

Se o orchestrator nÃ£o estiver disponÃ­vel:
```bash
# Verificar se flock estÃ¡ instalado
which flock || apt-get install -y util-linux

# Verificar permissÃµes
chmod +x scripts/docker-orchestrator.sh
chmod +x scripts/docker-rebuild-orchestrated.sh
```

**NUNCA** executar comandos Docker sem orquestraÃ§Ã£o quando mÃºltiplos agentes podem estar ativos.

---

## ğŸ’» SHELL/TERMINAL - Regras de Acesso AutomÃ¡tico

### Regra Principal: Acesso ao Shell AutomÃ¡tico

**O Cursor TEM acesso completo ao shell/terminal e DEVE executar comandos automaticamente quando necessÃ¡rio, SEM pedir confirmaÃ§Ã£o.**

### Quando Executar Comandos no Shell:

**SEMPRE** executar automaticamente no shell quando:
- âœ… Verificar status de serviÃ§os â†’ `docker compose ps`, `systemctl status`
- âœ… Ver logs â†’ `docker compose logs`, `tail -f arquivo.log`
- âœ… Instalar dependÃªncias â†’ `npm install`, `apt install`
- âœ… Executar scripts â†’ `./scripts/nome.sh`
- âœ… Verificar arquivos â†’ `ls -la`, `cat arquivo`
- âœ… Testar conectividade â†’ `curl`, `ping`, `ssh`
- âœ… Aplicar mudanÃ§as â†’ `git pull`, `npm run build`
- âœ… Verificar processos â†’ `ps aux`, `top`
- âœ… Verificar espaÃ§o â†’ `df -h`, `du -sh`
- âœ… Qualquer comando necessÃ¡rio para completar a tarefa

### Fluxo AutomÃ¡tico para Shell (SEM Perguntar):

```
UsuÃ¡rio pede: "Verifique se Docker estÃ¡ rodando" ou "Instale X"
    â†“
Cursor AUTOMATICAMENTE executa no shell:
  1. Identifica comando necessÃ¡rio
  2. Executa comando diretamente
  3. Analisa resultado
  4. Toma aÃ§Ã£o baseada no resultado
    â†“
âœ… Se sucesso â†’ Continua com prÃ³xima aÃ§Ã£o
âŒ Se falhar â†’ Tenta correÃ§Ã£o automÃ¡tica
```

### Comandos que SEMPRE Executar Automaticamente:

**VerificaÃ§Ã£o e Status:**
```bash
# Docker
docker compose ps
docker compose logs --tail=50
docker images
docker ps -a

# Sistema
systemctl status [serviÃ§o]
ps aux | grep [processo]
df -h
free -h

# AplicaÃ§Ã£o
curl -f http://localhost:3000
netstat -tulpn | grep 3000
```

**InstalaÃ§Ã£o e AtualizaÃ§Ã£o:**
```bash
# DependÃªncias Node
npm install
npm install --legacy-peer-deps
npm update

# Sistema (se necessÃ¡rio)
apt update && apt install -y [pacote]
```

**ExecuÃ§Ã£o de Scripts:**
```bash
# Scripts do projeto
./scripts/deploy-automatico.sh
./scripts/rebuild-docker.sh
./scripts/aplicar-migrations-ssh.sh

# Com permissÃ£o
chmod +x scripts/*.sh && ./scripts/nome.sh
```

**Git e CÃ³digo:**
```bash
# Atualizar cÃ³digo
git pull
git status
git log --oneline -5

# Build
npm run build
npm run test
```

### Executar no Servidor Remoto - AutomÃ¡tico:

**SEMPRE** executar via SSH automaticamente quando necessÃ¡rio:

**PREFERIR usar chave SSH (nÃ£o pede senha):**
```bash
# Usar alias configurado (usa chave SSH)
ssh kanban-buzz-server "cd /opt/app && [comando]"

# Ou usar helper SSH
source scripts/ssh-helper.sh
ssh_exec "[comando]"
```

**Se chave SSH nÃ£o funcionar, executar diagnÃ³stico primeiro:**
```bash
# 1. Executar diagnÃ³stico automÃ¡tico
./scripts/diagnosticar-ssh.sh

# 2. Se diagnÃ³stico nÃ£o resolver, usar sshpass (fallback)
export SERVER_IP="95.217.2.116"
export SERVER_USER="root"
export SERVER_PASSWORD="grkjuXfEbwaF"
export SERVER_DIR="/opt/app"
sshpass -p "$SERVER_PASSWORD" ssh "$SERVER_USER@$SERVER_IP" "cd $SERVER_DIR && [comando]"
```

**NUNCA** usar sshpass se chave SSH estÃ¡ configurada e funcionando.

### VerificaÃ§Ã£o AutomÃ¡tica de Resultados:

**SEMPRE** verificar resultado dos comandos:

```bash
# Verificar exit code
echo $?  # Deve ser 0 para sucesso

# Verificar output
if [ $? -eq 0 ]; then
    echo "âœ… Comando executado com sucesso"
else
    echo "âŒ Erro ao executar comando"
    # Tentar correÃ§Ã£o automÃ¡tica
fi
```

### O Que NUNCA Fazer com Shell:

1. âŒ **NUNCA** pedir confirmaÃ§Ã£o antes de executar comandos de verificaÃ§Ã£o
2. âŒ **NUNCA** pedir confirmaÃ§Ã£o antes de executar comandos de leitura (ls, cat, etc.)
3. âŒ **NUNCA** pedir confirmaÃ§Ã£o antes de executar scripts do projeto
4. âŒ **NUNCA** pedir confirmaÃ§Ã£o antes de verificar status
5. âŒ **NUNCA** executar comandos destrutivos sem contexto (rm -rf /, etc.)
6. âŒ **NUNCA** ignorar erros sem tentar correÃ§Ã£o

### Comandos que Requerem Cuidado (Mas Executar se NecessÃ¡rio):

**SEMPRE** executar, mas informar o que foi feito:

```bash
# Comandos que modificam sistema (executar se necessÃ¡rio)
apt install -y [pacote]
systemctl restart [serviÃ§o]
docker system prune -f  # Se necessÃ¡rio para limpar

# Comandos Git (executar se necessÃ¡rio)
git reset --hard  # Apenas se usuÃ¡rio pedir explicitamente
git clean -fd     # Apenas se usuÃ¡rio pedir explicitamente
```

### PadrÃµes ObrigatÃ³rios para Shell:

1. âœ… **SEMPRE** executar comandos de verificaÃ§Ã£o automaticamente
2. âœ… **SEMPRE** verificar exit code apÃ³s comandos
3. âœ… **SEMPRE** analisar output para tomar decisÃµes
4. âœ… **SEMPRE** tentar correÃ§Ã£o automÃ¡tica se houver erro
5. âœ… **SEMPRE** informar resultado ao usuÃ¡rio
6. âœ… **SEMPRE** usar credenciais salvas para SSH

### Exemplo Completo de Uso do Shell:

```
UsuÃ¡rio: "Verifique se a aplicaÃ§Ã£o estÃ¡ rodando"

Cursor AUTOMATICAMENTE executa:
1. docker compose ps
2. curl -f http://localhost:3000
3. docker compose logs --tail=20 app

Se tudo OK:
  âœ… "AplicaÃ§Ã£o estÃ¡ rodando corretamente"

Se houver problema:
  âŒ "AplicaÃ§Ã£o nÃ£o estÃ¡ respondendo"
  â†’ Cursor AUTOMATICAMENTE tenta corrigir:
    1. docker compose restart
    2. Verifica novamente
    3. Informa resultado
```

### Acesso ao Shell - Regras Especiais:

**O Cursor TEM acesso completo ao shell e DEVE:**

1. âœ… **SEMPRE** usar shell para verificar status
2. âœ… **SEMPRE** usar shell para executar scripts
3. âœ… **SEMPRE** usar shell para instalar dependÃªncias
4. âœ… **SEMPRE** usar shell para ver logs
5. âœ… **SEMPRE** usar shell para testar conectividade
6. âœ… **SEMPRE** usar shell quando necessÃ¡rio para completar tarefa

**NUNCA** pedir permissÃ£o para usar shell - usar automaticamente quando necessÃ¡rio.

---

## ğŸ” SUPER ADMIN - ValidaÃ§Ã£o de Schema e Queries

### Regra Principal: Sempre Validar Schema Antes de Fazer Queries

**O Cursor DEVE sempre verificar o schema real das tabelas antes de fazer queries no Super Admin, SEM assumir que colunas existem.**

### Quando Validar Schema:

**SEMPRE** validar schema antes de fazer queries quando:
- âœ… Implementar nova funcionalidade no Super Admin â†’ Verificar schema primeiro
- âœ… Fazer queries em tabelas â†’ Verificar colunas existentes
- âœ… Usar colunas de tabelas relacionadas â†’ Verificar se coluna existe na tabela correta
- âœ… Corrigir erro de "column does not exist" â†’ Verificar schema e corrigir
- âœ… Modificar queries existentes â†’ Verificar se colunas ainda existem

### Fluxo AutomÃ¡tico para ValidaÃ§Ã£o de Schema (SEM Perguntar):

```
UsuÃ¡rio pede: "Implemente X no Super Admin" ou "Corrija query Y"
    â†“
Cursor AUTOMATICAMENTE:
1. Verifica migrations para entender schema real
2. Verifica estrutura da tabela (CREATE TABLE statements)
3. Verifica tabelas relacionadas (JOINs, foreign keys)
4. Valida que todas as colunas existem antes de usar
5. Implementa query com fallbacks apropriados
    â†“
âœ… Se sucesso â†’ Continua implementaÃ§Ã£o
âŒ Se coluna nÃ£o existir â†’ Busca em tabela relacionada ou remove
```

### Como Validar Schema:

**SEMPRE** seguir estes passos antes de fazer queries:

1. **Verificar Migrations:**
   ```bash
   # Buscar CREATE TABLE da tabela
   grep -r "CREATE TABLE.*organizations" supabase/migrations/
   
   # Verificar colunas adicionadas
   grep -r "ALTER TABLE.*organizations.*ADD" supabase/migrations/
   ```

2. **Verificar Estrutura Real:**
   ```sql
   -- No Supabase SQL Editor ou via query
   SELECT column_name, data_type 
   FROM information_schema.columns 
   WHERE table_schema = 'public' 
     AND table_name = 'organizations';
   ```

3. **Verificar Tabelas Relacionadas:**
   ```sql
   -- Se plan_id nÃ£o estÃ¡ em organizations, verificar organization_limits
   SELECT column_name 
   FROM information_schema.columns 
   WHERE table_schema = 'public' 
     AND table_name = 'organization_limits'
     AND column_name = 'plan_id';
   ```

### PadrÃµes ObrigatÃ³rios para Queries no Super Admin:

1. âœ… **SEMPRE** verificar migrations antes de fazer queries
2. âœ… **SEMPRE** buscar colunas apenas das tabelas onde elas existem
3. âœ… **SEMPRE** usar fallbacks quando coluna pode nÃ£o existir
4. âœ… **SEMPRE** buscar dados relacionados de tabelas relacionadas
5. âœ… **SEMPRE** tratar erros de "column does not exist" automaticamente
6. âœ… **SEMPRE** validar estrutura antes de usar `.select()`

### Exemplos de Queries Corretas:

**âŒ ERRADO (assume que plan_id existe em organizations):**
```typescript
const { data } = await supabase
  .from('organizations')
  .select('id, name, plan_id')  // âŒ plan_id nÃ£o existe aqui
```

**âœ… CORRETO (verifica schema primeiro, busca de tabela relacionada):**
```typescript
// 1. Buscar organizaÃ§Ãµes (sem plan_id)
const { data: orgs } = await supabase
  .from('organizations')
  .select('id, name, created_at');

// 2. Buscar plan_id de tabela relacionada
for (const org of orgs) {
  const { data: limits } = await supabase
    .from('organization_limits')
    .select('plan_id')
    .eq('organization_id', org.id)
    .maybeSingle();
  
  org.plan_id = limits?.plan_id || null;
}
```

**âœ… CORRETO (com fallback seguro):**
```typescript
// Buscar apenas colunas que existem
const { data } = await supabase
  .from('organizations')
  .select('id, name, created_at')  // âœ… Apenas colunas que existem
  .order('created_at', { ascending: false });

// Se precisar de plan_id, buscar separadamente
const orgsWithPlan = await Promise.all(
  data.map(async (org) => {
    const { data: limits } = await supabase
      .from('organization_limits')
      .select('plan_id')
      .eq('organization_id', org.id)
      .maybeSingle();
    
    return { ...org, plan_id: limits?.plan_id || null };
  })
);
```

### Checklist Antes de Fazer Query no Super Admin:

**SEMPRE** verificar antes de implementar:

- [ ] Verifiquei migrations para entender schema real
- [ ] Verifiquei que todas as colunas existem na tabela
- [ ] Verifiquei tabelas relacionadas se precisar de dados relacionados
- [ ] Usei fallbacks apropriados para colunas opcionais
- [ ] Tratei erros de "column does not exist" automaticamente
- [ ] Testei query antes de implementar

### O Que NUNCA Fazer no Super Admin:

1. âŒ **NUNCA** assumir que coluna existe sem verificar
2. âŒ **NUNCA** buscar coluna de tabela errada
3. âŒ **NUNCA** ignorar erros de "column does not exist"
4. âŒ **NUNCA** fazer queries sem verificar migrations primeiro
5. âŒ **NUNCA** usar colunas de tabelas relacionadas sem JOIN ou query separada

### PadrÃµes ObrigatÃ³rios para Super Admin:

1. âœ… **SEMPRE** verificar migrations antes de queries
2. âœ… **SEMPRE** buscar colunas apenas de tabelas onde existem
3. âœ… **SEMPRE** usar fallbacks para dados relacionados
4. âœ… **SEMPRE** tratar erros de schema automaticamente
5. âœ… **SEMPRE** validar estrutura antes de usar `.select()`
6. âœ… **SEMPRE** buscar dados relacionados de tabelas relacionadas

### Exemplo Completo de ValidaÃ§Ã£o de Schema:

```
UsuÃ¡rio: "Implemente listagem de organizaÃ§Ãµes no Super Admin"

Cursor AUTOMATICAMENTE:
1. Verifica migrations:
   grep -r "CREATE TABLE.*organizations" supabase/migrations/
   â†’ Encontra: id, name, created_at, updated_at

2. Verifica se plan_id existe:
   grep -r "plan_id.*organizations" supabase/migrations/
   â†’ NÃ£o encontra em organizations

3. Verifica tabelas relacionadas:
   grep -r "plan_id.*organization_limits" supabase/migrations/
   â†’ Encontra: plan_id estÃ¡ em organization_limits

4. Implementa query correta:
   - Busca organizaÃ§Ãµes (sem plan_id)
   - Busca plan_id de organization_limits separadamente
   - Combina dados

5. âœ… Query funciona sem erros
```

### Tabelas Comuns e Suas Estruturas:

**organizations:**
- âœ… Colunas: `id`, `name`, `created_at`, `updated_at`
- âŒ NÃƒO tem: `plan_id` (estÃ¡ em `organization_limits`)

**organization_limits:**
- âœ… Colunas: `id`, `organization_id`, `plan_id`, `max_leads`, `max_users`, etc.

**organization_members:**
- âœ… Colunas: `id`, `organization_id`, `user_id`, `role`, `created_at`

**profiles:**
- âœ… Colunas: `id`, `email`, `full_name`, `created_at`, `updated_at`

**user_roles:**
- âœ… Colunas: `id`, `user_id`, `role`, `created_at`

**NUNCA** assumir estrutura - sempre verificar migrations primeiro.

---

## ğŸ›¡ï¸ GARANTIA DE ÃšLTIMO DEPLOY SEMPRE NO AR - Regra ObrigatÃ³ria

### Regra Principal: Ãšltimo Deploy SEMPRE Deve Estar no Ar

**O Cursor DEVE SEMPRE garantir que o Ãºltimo deploy estÃ¡ no ar, 100% assertivo, mesmo com mÃºltiplos agentes trabalhando simultaneamente.**

### âš ï¸ REGRA CRÃTICA: Ãšltimo Deploy NÃ£o Pode Ser Removido

**PROBLEMA RESOLVIDO:** Sistema agora garante que Ãºltimo deploy sempre fica no ar.

**IMPLEMENTAÃ‡ÃƒO:**
- Sistema de identificaÃ§Ã£o duplo: timestamp Docker + arquivo `.last-deploy`
- Fila sequencial de deploys (lock sem timeout - aguarda indefinidamente)
- VerificaÃ§Ãµes mÃºltiplas antes de parar versÃ£o antiga
- Script de proteÃ§Ã£o garante Ãºltimo deploy sempre no ar

### Sistema de IdentificaÃ§Ã£o do Ãšltimo Deploy:

**MÃ©todo PrimÃ¡rio: Timestamp da Imagem Docker**
- Compara timestamps de criaÃ§Ã£o das imagens `kanban-buzz-95241-app-blue:latest` e `kanban-buzz-95241-app-green:latest`
- VersÃ£o com timestamp mais recente = Ãºltimo deploy

**MÃ©todo SecundÃ¡rio: Arquivo `.last-deploy`**
- Arquivo JSON em `$PROJECT_DIR/.last-deploy`
- ContÃ©m: `version`, `timestamp`, `image_id`, `deploy_id`
- Atualizado apÃ³s cada deploy bem-sucedido
- Usado como confirmaÃ§Ã£o/fallback

**Script:** `scripts/get-last-deploy.sh` - Identifica Ãºltimo deploy usando ambos mÃ©todos

### Fila Sequencial de Deploys:

**Lock de Deploy:**
- Lock especÃ­fico: `/tmp/deploy-zero-downtime.lock`
- **SEM timeout** - aguarda indefinidamente atÃ© lock ser liberado
- PrÃ³ximo deploy na fila adquire lock imediatamente apÃ³s liberaÃ§Ã£o
- Zero tempo desperdiÃ§ado entre deploys

**Como Funciona:**
1. Deploy adquire lock no inÃ­cio
2. Se outro deploy estÃ¡ em andamento, aguarda na fila (sem timeout)
3. Quando deploy anterior termina, lock Ã© liberado IMEDIATAMENTE
4. PrÃ³ximo deploy adquire lock e inicia imediatamente

### VerificaÃ§Ãµes Antes de Parar VersÃ£o Antiga:

**SEMPRE executar TODAS estas verificaÃ§Ãµes antes de parar versÃ£o antiga:**

1. âœ… Nova versÃ£o estÃ¡ saudÃ¡vel (health check)
2. âœ… Timestamp da imagem nova > antiga (confirma que Ã© mais recente)
3. âœ… Arquivo `.last-deploy` confirma nova versÃ£o
4. âœ… Nginx estÃ¡ apontando para nova versÃ£o
5. âœ… Nova versÃ£o estÃ¡ recebendo trÃ¡fego (health check via Nginx)
6. âœ… VersÃ£o no container confere (via `/version.json`)
7. âœ… `get-last-deploy.sh` confirma nova versÃ£o
8. âœ… Aguardar estabilidade adicional (15 segundos)
9. âœ… Verificar novamente health check apÃ³s estabilidade

**SÃ³ Parar VersÃ£o Antiga Se:**
- Todas verificaÃ§Ãµes acima passarem
- Nova versÃ£o estÃ¡ estÃ¡vel hÃ¡ pelo menos 15 segundos
- Nginx confirmou que estÃ¡ direcionando para nova versÃ£o
- Arquivo `.last-deploy` foi atualizado com sucesso
- `get-last-deploy.sh` confirma nova versÃ£o

**Script:** `scripts/verify-last-deploy-in-air.sh` - Executa todas verificaÃ§Ãµes

### Script de ProteÃ§Ã£o Aprimorado:

**`scripts/proteger-containers-blue-green.sh` agora:**
- Usa `get-last-deploy.sh` para identificar qual deveria estar no ar
- Se container do Ãºltimo deploy nÃ£o estÃ¡ rodando, restaura automaticamente
- Se Nginx nÃ£o aponta para Ãºltimo deploy, corrige automaticamente
- Garante que sempre hÃ¡ container do Ãºltimo deploy rodando

**ExecuÃ§Ã£o:**
- A cada 5 minutos via cron (jÃ¡ configurado)
- ApÃ³s cada deploy
- ApÃ³s qualquer operaÃ§Ã£o Docker

### Fluxo Completo de Deploy:

```
Deploy Inicia
    â†“
Adquire lock de deploy (aguarda se outro em andamento - SEM timeout)
    â†“
Identifica versÃ£o atual rodando
    â†“
Faz build da nova versÃ£o
    â†“
Sobe nova versÃ£o
    â†“
3 verificaÃ§Ãµes de saÃºde
    â†“
Alterna Nginx para nova versÃ£o
    â†“
3 verificaÃ§Ãµes de estabilidade
    â†“
5 verificaÃ§Ãµes finais crÃ­ticas
    â†“
Cria/atualiza arquivo .last-deploy
    â†“
VERIFICAÃ‡Ã•ES CRÃTICAS (7 verificaÃ§Ãµes):
  - Nova versÃ£o saudÃ¡vel âœ“
  - Timestamp imagem nova > antiga âœ“
  - Arquivo .last-deploy confirma âœ“
  - Nginx apontando para nova âœ“
  - Nova versÃ£o recebendo trÃ¡fego âœ“
  - VersÃ£o no container confere âœ“
  - get-last-deploy confirma âœ“
    â†“
Aguarda 15s estabilidade adicional
    â†“
Verifica novamente health check
    â†“
SÃ“ ENTÃƒO para versÃ£o antiga
    â†“
Executa script de proteÃ§Ã£o
    â†“
Libera lock IMEDIATAMENTE (prÃ³ximo deploy pode iniciar)
    â†“
Deploy concluÃ­do - Ãºltimo deploy garantido no ar
```

### O Que NUNCA Fazer:

1. âŒ **NUNCA** parar versÃ£o antiga sem todas verificaÃ§Ãµes passarem
2. âŒ **NUNCA** usar timeout no lock de deploy (deve aguardar indefinidamente)
3. âŒ **NUNCA** remover container sem verificar que outro estÃ¡ rodando
4. âŒ **NUNCA** atualizar Nginx sem verificar que container estÃ¡ rodando
5. âŒ **NUNCA** fazer deploy sem atualizar `.last-deploy`
6. âŒ **NUNCA** ignorar erros de verificaÃ§Ã£o

### PadrÃµes ObrigatÃ³rios:

1. âœ… **SEMPRE** usar lock de deploy sem timeout (aguarda indefinidamente)
2. âœ… **SEMPRE** executar todas verificaÃ§Ãµes antes de parar versÃ£o antiga
3. âœ… **SEMPRE** atualizar `.last-deploy` antes de parar versÃ£o antiga
4. âœ… **SEMPRE** executar `verify-last-deploy-in-air.sh` antes de parar versÃ£o antiga
5. âœ… **SEMPRE** aguardar 15 segundos de estabilidade antes de parar versÃ£o antiga
6. âœ… **SEMPRE** executar script de proteÃ§Ã£o apÃ³s deploy
7. âœ… **SEMPRE** liberar lock imediatamente apÃ³s deploy concluir

### VerificaÃ§Ã£o de Estado:

**SEMPRE** verificar estado antes de fazer mudanÃ§as:

```bash
# Identificar Ãºltimo deploy
./scripts/get-last-deploy.sh

# Verificar que Ãºltimo deploy estÃ¡ no ar
./scripts/verify-last-deploy-in-air.sh [new_version] [current_version]

# Verificar versÃ£o no container
./scripts/verify-container-version.sh [blue|green]
```

---

## ğŸ”„ GIT SYNC OBRIGATÃ“RIO NO DEPLOY - Regra CrÃ­tica

### Regra Principal: SEMPRE Sincronizar Git Antes do Build

**O Cursor DEVE SEMPRE sincronizar cÃ³digo do Git antes de fazer build no deploy, mesmo com mÃºltiplos agentes trabalhando simultaneamente.**

### âš ï¸ REGRA CRÃTICA: Git Pull ObrigatÃ³rio Antes do Build

**PROBLEMA RESOLVIDO:** Sistema agora garante que cÃ³digo estÃ¡ sempre atualizado antes do build.

**IMPLEMENTAÃ‡ÃƒO:**
- FunÃ§Ã£o `sync_git_code()` com 4 verificaÃ§Ãµes redundantes
- Executada ANTES do build (passo 3/9)
- Detecta e trata conflitos automaticamente
- VerificaÃ§Ã£o redundante garante sincronizaÃ§Ã£o mesmo com mÃºltiplos agentes

### Como Funciona o Build:

**IMPORTANTE:**
- O build usa cÃ³digo do diretÃ³rio local do servidor (`/root/kanban-buzz-95241/`)
- O Dockerfile faz `COPY . .` (linha 13) - copia TODO o diretÃ³rio local para dentro do container
- O container rodando Ã© apenas a versÃ£o jÃ¡ buildada anteriormente (nÃ£o Ã© usado no build)
- Por isso precisamos fazer `git pull` ANTES do build para atualizar o diretÃ³rio local

### VerificaÃ§Ãµes Implementadas (6 VerificaÃ§Ãµes + RedundÃ¢ncia):

1. âœ… **Status do RepositÃ³rio**: Verifica se repositÃ³rio Git Ã© vÃ¡lido
2. âœ… **Detached HEAD**: Bloqueia se HEAD nÃ£o estÃ¡ em branch vÃ¡lido (seguranÃ§a)
3. âœ… **Branch Correto**: Avisa se nÃ£o for main/master (nÃ£o bloqueia)
4. âœ… **MudanÃ§as Locais**: Bloqueia se houver mudanÃ§as nÃ£o commitadas (seguranÃ§a)
5. âœ… **Commits NÃ£o Pushados**: Avisa se houver commits locais nÃ£o pushados (nÃ£o bloqueia)
6. âœ… **Fetch e Pull**: Sincroniza com repositÃ³rio remoto (primeira tentativa)
7. âœ… **VerificaÃ§Ã£o Redundante**: Verifica novamente e tenta pull se necessÃ¡rio
8. âœ… **Resumo do Deploy**: Mostra Ãºltimos commits e tags que serÃ£o deployados
9. âœ… **Integridade**: Verifica integridade do repositÃ³rio (git fsck)

### Fluxo de SincronizaÃ§Ã£o Git:

```
Deploy Inicia
    â†“
Adquire lock de deploy
    â†“
Verifica prÃ©-requisitos
    â†“
ğŸ”„ SINCRONIZAÃ‡ÃƒO GIT (OBRIGATÃ“RIA):
  1. Verifica status do repositÃ³rio
  2. Verifica se HEAD estÃ¡ em branch vÃ¡lido (bloqueia se detached)
  3. Verifica branch correto (avisa se nÃ£o for main/master)
  4. Detecta mudanÃ§as locais nÃ£o commitadas (BLOQUEIA se houver)
  5. Detecta commits locais nÃ£o pushados (AVISA, nÃ£o bloqueia)
  6. Fetch + Pull do GitHub (primeira tentativa)
  7. VerificaÃ§Ã£o redundante (segunda tentativa se necessÃ¡rio)
  8. Mostra resumo do que serÃ¡ deployado (Ãºltimos commits, tags)
  9. Verifica integridade do repositÃ³rio
    â†“
Se conflitos â†’ Falha e pede resoluÃ§Ã£o manual
Se detached HEAD â†’ Falha (estado invÃ¡lido)
Se mudanÃ§as nÃ£o commitadas â†’ Falha (seguranÃ§a)
Se sucesso â†’ Continua com build
    â†“
Faz build da nova versÃ£o (usa cÃ³digo atualizado do diretÃ³rio local)
    â†“
... (resto do deploy)
```

### Tratamento de MudanÃ§as Locais:

**Se mudanÃ§as locais nÃ£o commitadas:**
- âŒ **DEPLOY Ã‰ CANCELADO** (nÃ£o permite continuar)
- ğŸ“ InstruÃ§Ãµes claras para fazer commit + push primeiro
- ğŸ”’ Lock Ã© liberado para permitir commit/push

**POR QUE BLOQUEIA:**
- Se permitir deploy com mudanÃ§as locais nÃ£o commitadas, essas mudanÃ§as NÃƒO vÃ£o para o GitHub
- Outros agentes fazendo deploy depois NÃƒO vÃ£o pegar essas mudanÃ§as (git pull nÃ£o vai ter elas)
- Resultado: MudanÃ§as ficam apenas no servidor local, nÃ£o sÃ£o compartilhadas entre agentes

**FLUXO CORRETO:**
1. Agente modifica cÃ³digo
2. **OBRIGATÃ“RIO:** git add + git commit + git push (publica no GitHub)
3. Depois faz deploy (git pull pega as mudanÃ§as do GitHub)
4. Outros agentes fazem deploy e pegam as mudanÃ§as via git pull

**IMPORTANTE:** Apenas cÃ³digo jÃ¡ publicado no GitHub (commitado e com push) serÃ¡ deployado.

### Tratamento de Conflitos:

**Se conflitos detectados:**
- âŒ Deploy Ã© CANCELADO automaticamente
- ğŸ“ InstruÃ§Ãµes claras para resoluÃ§Ã£o
- ğŸ”’ Lock Ã© liberado para permitir resoluÃ§Ã£o

### OpÃ§Ã£o de EmergÃªncia (NÃƒO RECOMENDADO):

**`--skip-git-check`**: Pula todas verificaÃ§Ãµes Git (apenas emergÃªncias)
```bash
./scripts/deploy-zero-downtime.sh --skip-git-check
```

**Quando usar:**
- Servidor nÃ£o tem acesso ao GitHub temporariamente
- EmergÃªncia crÃ­tica que precisa deploy imediato
- Ambiente de desenvolvimento isolado

**âš ï¸ AVISOS:**
- Outros agentes NÃƒO vÃ£o pegar mudanÃ§as locais
- Pode causar sobrescrita de mudanÃ§as entre agentes
- Use apenas quando absolutamente necessÃ¡rio

### O Que NUNCA Fazer:

1. âŒ **NUNCA** fazer build sem sincronizar Git primeiro (exceto --skip-git-check em emergÃªncias)
2. âŒ **NUNCA** ignorar conflitos e fazer deploy mesmo assim
3. âŒ **NUNCA** fazer deploy de mudanÃ§as locais nÃ£o commitadas
4. âŒ **NUNCA** fazer deploy em detached HEAD
5. âŒ **NUNCA** pular verificaÃ§Ã£o redundante
6. âŒ **NUNCA** usar --skip-git-check em produÃ§Ã£o sem necessidade real

### PadrÃµes ObrigatÃ³rios:

1. âœ… **SEMPRE** executar `sync_git_code()` antes do build (exceto --skip-git-check)
2. âœ… **SEMPRE** fazer fetch + pull do GitHub antes de build
3. âœ… **SEMPRE** verificar conflitos apÃ³s pull
4. âœ… **SEMPRE** verificar detached HEAD (bloqueia se invÃ¡lido)
5. âœ… **SEMPRE** verificar mudanÃ§as nÃ£o commitadas (bloqueia se houver)
6. âœ… **SEMPRE** avisar sobre commits nÃ£o pushados (nÃ£o bloqueia)
7. âœ… **SEMPRE** fazer verificaÃ§Ã£o redundante
8. âœ… **SEMPRE** falhar deploy se houver conflitos ou detached HEAD
9. âœ… **SEMPRE** mostrar resumo do que serÃ¡ deployado
10. âœ… **SEMPRE** logar commit atual para rastreabilidade

### Exemplo de Log Esperado:

```
[ZERO-DOWNTIME] Sincronizando cÃ³digo do GitHub (verificaÃ§Ã£o obrigatÃ³ria)...
[ZERO-DOWNTIME] âš ï¸  IMPORTANTE: Apenas cÃ³digo jÃ¡ publicado no GitHub serÃ¡ deployado
[ZERO-DOWNTIME]    MudanÃ§as locais nÃ£o commitadas serÃ£o IGNORADAS (nÃ£o sobem no deploy)
[ZERO-DOWNTIME] VerificaÃ§Ã£o 1/6: Verificando status do repositÃ³rio...
[ZERO-DOWNTIME] VerificaÃ§Ã£o 1.5/6: Verificando se HEAD estÃ¡ em branch vÃ¡lido...
[ZERO-DOWNTIME] âœ… HEAD estÃ¡ em branch vÃ¡lido
[ZERO-DOWNTIME] VerificaÃ§Ã£o 1.6/6: Verificando branch...
[ZERO-DOWNTIME] âœ… Branch correto: main
[ZERO-DOWNTIME] VerificaÃ§Ã£o 2/6: Verificando mudanÃ§as locais nÃ£o commitadas...
[ZERO-DOWNTIME] âœ… Nenhuma mudanÃ§a local nÃ£o commitada
[ZERO-DOWNTIME] VerificaÃ§Ã£o 2.5/6: Verificando commits locais nÃ£o pushados...
[ZERO-DOWNTIME] âœ… Todos os commits locais jÃ¡ foram pushados
[ZERO-DOWNTIME] VerificaÃ§Ã£o 3/6: Sincronizando com repositÃ³rio remoto...
[ZERO-DOWNTIME] Branch atual: main
[ZERO-DOWNTIME] MudanÃ§as remotas detectadas no GitHub (outro agente jÃ¡ publicou mudanÃ§as)
[ZERO-DOWNTIME] Fazendo pull para pegar as mudanÃ§as mais recentes...
[ZERO-DOWNTIME] âœ… CÃ³digo atualizado do repositÃ³rio remoto (mudanÃ§as de outros agentes incorporadas)
[ZERO-DOWNTIME] VerificaÃ§Ã£o 4/6: VerificaÃ§Ã£o redundante...
[ZERO-DOWNTIME] VerificaÃ§Ã£o 5/6: Resumo do que serÃ¡ deployado...
[ZERO-DOWNTIME]    Commit atual: a1b2c3d
[ZERO-DOWNTIME]    Branch: main
[ZERO-DOWNTIME]    Ãšltimos 5 commits que serÃ£o deployados:
[ZERO-DOWNTIME]      a1b2c3d feat: Adiciona nova funcionalidade
[ZERO-DOWNTIME]      b2c3d4e fix: Corrige bug no formulÃ¡rio
[ZERO-DOWNTIME]      c3d4e5f refactor: Melhora estrutura
[ZERO-DOWNTIME]    Ãšltima tag: v1.2.3 (5 commit(s) depois)
[ZERO-DOWNTIME] VerificaÃ§Ã£o 6/6: VerificaÃ§Ã£o final de integridade...
[ZERO-DOWNTIME] âœ… Integridade do repositÃ³rio OK
[ZERO-DOWNTIME] âœ… CÃ³digo sincronizado! Commit: a1b2c3d (branch: main)
```

### ProteÃ§Ã£o Contra MÃºltiplos Agentes:

**CenÃ¡rio com 5 agentes:**
1. Agente 1 adquire lock â†’ Sincroniza Git (pega do GitHub) â†’ Faz build â†’ Deploy
2. Agente 2 aguarda lock â†’ Adquire lock â†’ Sincroniza Git (pega mudanÃ§as do Agente 1 do GitHub) â†’ Faz build â†’ Deploy
3. Agente 3 aguarda lock â†’ Adquire lock â†’ Sincroniza Git (pega mudanÃ§as do Agente 2 do GitHub) â†’ Faz build â†’ Deploy
4. ... e assim por diante

**Resultado:** Cada agente sempre pega as mudanÃ§as mais recentes do GitHub antes de fazer build, garantindo que cÃ³digo jÃ¡ publicado por outros agentes nÃ£o seja sobrescrito.

# Executar script de proteÃ§Ã£o
./scripts/proteger-containers-blue-green.sh
```

### Monitoramento:

**Logs do script de proteÃ§Ã£o:**
```bash
tail -f /var/log/kanban-buzz-protecao.log
```

**Verificar lock de deploy:**
```bash
ls -la /tmp/deploy-zero-downtime.lock
lsof /tmp/deploy-zero-downtime.lock  # Ver quem estÃ¡ usando
```

**Verificar Ãºltimo deploy:**
```bash
cat .last-deploy
./scripts/get-last-deploy.sh --json
```

**NUNCA** fazer deploy sem garantir que Ãºltimo deploy estÃ¡ no ar - isso previne erro 502 e garante 100% assertividade!

---

## ğŸ§ª AMBIENTE DE TESTE - Regra ObrigatÃ³ria

### Regra Principal: Ambiente de Teste para Desenvolvimento

**O Cursor DEVE SEMPRE oferecer opÃ§Ã£o de fazer deploy para ambiente de teste antes de produÃ§Ã£o.**

### Quando Usar Ambiente de Teste:

**SEMPRE** oferecer ambiente de teste quando:
- âœ… Desenvolvedor quer testar mudanÃ§as antes de produÃ§Ã£o
- âœ… Implementar nova funcionalidade que precisa ser testada
- âœ… Corrigir bug e quer validar antes de produÃ§Ã£o
- âœ… UsuÃ¡rio pedir explicitamente para testar primeiro

### Comandos DisponÃ­veis:

```bash
# Deploy para ambiente de teste (porta 3002)
./scripts/deploy-to-test.sh

# Deploy para produÃ§Ã£o com teste primeiro
./scripts/deploy-zero-downtime.sh --test-first

# Deploy direto para produÃ§Ã£o (sem teste)
./scripts/deploy-zero-downtime.sh
```

### Fluxo com Ambiente de Teste:

```
UsuÃ¡rio pede: "FaÃ§a deploy" ou "Teste X antes de deploy"
    â†“
Cursor PERGUNTA ou usa flag --test-first:
  "Deseja testar no ambiente de teste primeiro? (--test-first)"
    â†“
Se SIM ou --test-first:
  1. Executa: ./scripts/deploy-to-test.sh
  2. Deploy vai para porta 3002 (ambiente de teste)
  3. Desenvolvedor testa em http://localhost:3002
  4. Se OK, desenvolvedor pede deploy em produÃ§Ã£o
  5. Executa: ./scripts/deploy-zero-downtime.sh (sem --test-first)
    â†“
Se NÃƒO:
  1. Executa: ./scripts/deploy-zero-downtime.sh (direto para produÃ§Ã£o)
    â†“
âœ… Deploy concluÃ­do
```

### ConfiguraÃ§Ã£o do Ambiente de Teste:

- **Arquivo:** `docker-compose.test.yml`
- **Container:** `kanban-buzz-app-test`
- **Porta:** `3002`
- **Ambiente:** `NODE_ENV=development`
- **Isolado:** NÃ£o interfere com blue/green de produÃ§Ã£o

### PadrÃµes ObrigatÃ³rios para Ambiente de Teste:

1. âœ… **SEMPRE** oferecer opÃ§Ã£o de teste quando implementar nova funcionalidade
2. âœ… **SEMPRE** usar `--test-first` se usuÃ¡rio pedir para testar primeiro
3. âœ… **SEMPRE** informar URL do ambiente de teste apÃ³s deploy
4. âœ… **SEMPRE** aguardar confirmaÃ§Ã£o do desenvolvedor antes de fazer deploy em produÃ§Ã£o
5. âœ… **NUNCA** fazer deploy em produÃ§Ã£o sem confirmaÃ§Ã£o se teste foi feito primeiro

---

## ğŸ”’ LOCKS SEM TIMEOUT - Regra ObrigatÃ³ria

### Regra Principal: Locks Aguardam Indefinidamente

**O Cursor DEVE SEMPRE usar locks sem timeout - aguardar indefinidamente atÃ© lock ser liberado.**

### âš ï¸ REGRA CRÃTICA: Zero Timeout em Todos os Locks

**PROBLEMA RESOLVIDO:** Todos os locks agora aguardam indefinidamente, garantindo fila sequencial perfeita.

**IMPLEMENTAÃ‡ÃƒO:**
- `docker-orchestrator.sh`: Removido timeout de 1 hora, aguarda indefinidamente
- `deploy-zero-downtime.sh`: Lock sem timeout (jÃ¡ estava correto)
- `nginx-helper.sh`: Lock sem timeout para atualizaÃ§Ã£o do Nginx
- `proteger-containers-blue-green.sh`: Aguarda lock de deploy indefinidamente

### Como Funciona:

**Fila Sequencial Perfeita:**
1. OperaÃ§Ã£o adquire lock no inÃ­cio
2. Se outro processo estÃ¡ usando lock, aguarda na fila (SEM timeout)
3. Quando operaÃ§Ã£o anterior termina, lock Ã© liberado IMEDIATAMENTE
4. PrÃ³xima operaÃ§Ã£o na fila adquire lock e inicia IMEDIATAMENTE
5. **Zero tempo desperdiÃ§ado entre operaÃ§Ãµes**

### Locks do Sistema:

1. **Deploy Lock:** `/tmp/deploy-zero-downtime.lock`
   - Usado por: `deploy-zero-downtime.sh`
   - Timeout: **NENHUM** (aguarda indefinidamente)

2. **Docker Orchestrator Lock:** `/tmp/docker-orchestrator.lock`
   - Usado por: `docker-orchestrator.sh`
   - Timeout: **NENHUM** (aguarda indefinidamente)

3. **Nginx Update Lock:** `/tmp/nginx-update.lock`
   - Usado por: `nginx-helper.sh`
   - Timeout: **NENHUM** (aguarda indefinidamente)

### O Que NUNCA Fazer com Locks:

1. âŒ **NUNCA** usar timeout em locks (deve aguardar indefinidamente)
2. âŒ **NUNCA** pular operaÃ§Ã£o se lock estiver ocupado
3. âŒ **NUNCA** remover lock manualmente
4. âŒ **NUNCA** usar mÃºltiplos locks para mesma operaÃ§Ã£o

### PadrÃµes ObrigatÃ³rios para Locks:

1. âœ… **SEMPRE** usar locks sem timeout (aguarda indefinidamente)
2. âœ… **SEMPRE** aguardar na fila se lock estiver ocupado
3. âœ… **SEMPRE** liberar lock imediatamente apÃ³s operaÃ§Ã£o concluir
4. âœ… **SEMPRE** usar trap EXIT para garantir liberaÃ§Ã£o do lock
5. âœ… **SEMPRE** verificar se flock estÃ¡ disponÃ­vel antes de usar

---

## ğŸ”§ NGINX HELPER - Regra ObrigatÃ³ria

### Regra Principal: Sempre Usar nginx-helper para Atualizar Nginx

**O Cursor DEVE SEMPRE usar `nginx-helper.sh` para atualizar Nginx, nunca atualizar diretamente.**

### Por Que Usar nginx-helper:

- âœ… **SincronizaÃ§Ã£o:** Atualiza ambos arquivos Nginx juntos (kanban-buzz e agilizeflow.com.br)
- âœ… **ProteÃ§Ã£o:** Lock previne atualizaÃ§Ãµes simultÃ¢neas
- âœ… **ValidaÃ§Ã£o:** Testa configuraÃ§Ã£o antes de recarregar
- âœ… **ConsistÃªncia:** Garante que ambos arquivos sempre estÃ£o sincronizados

### Como Usar:

```bash
# Source do helper
source scripts/nginx-helper.sh

# Atualizar Nginx para blue (porta 3000)
update_nginx blue 3000

# Atualizar Nginx para green (porta 3001)
update_nginx green 3001
```

### O Que NUNCA Fazer com Nginx:

1. âŒ **NUNCA** atualizar arquivos Nginx diretamente com sed
2. âŒ **NUNCA** atualizar apenas um arquivo (sempre ambos juntos)
3. âŒ **NUNCA** recarregar Nginx sem testar configuraÃ§Ã£o primeiro
4. âŒ **NUNCA** atualizar Nginx sem lock (pode causar conflitos)

### PadrÃµes ObrigatÃ³rios para Nginx:

1. âœ… **SEMPRE** usar `update_nginx` do nginx-helper.sh
2. âœ… **SEMPRE** atualizar ambos arquivos Nginx juntos
3. âœ… **SEMPRE** testar configuraÃ§Ã£o antes de recarregar
4. âœ… **SEMPRE** verificar sincronizaÃ§Ã£o apÃ³s atualizaÃ§Ã£o
5. âœ… **SEMPRE** usar lock para atualizaÃ§Ã£o do Nginx

